package main

import (
	"bytes"
	"fmt"
	"image"
	"image/color"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	_ "golang.org/x/image/bmp"
	_ "image/gif"
	_ "image/jpeg"
	_ "image/png"
)

func main() {
	if len(os.Args) != 4 {
		fmt.Println("usage:")
		fmt.Println("  arg 1: image file path")
		fmt.Println("  arg 2: ouptut file path (.h or .pas)")
		fmt.Println("  arg 3: format (e.g. RGBA or BGR or RRRABR)")
		return
	}

	imageFile, err := os.Open(os.Args[1])
	if err != nil {
		panic(err)
	}
	defer imageFile.Close()

	img, _, err := image.Decode(imageFile)
	if err != nil {
		panic(err)
	}

	_, imageFileName := filepath.Split(os.Args[1])
	imageName := strings.TrimSuffix(imageFileName, filepath.Ext(imageFileName))

	buffer := bytes.NewBuffer(nil)
	output := panickyWriter{buffer}

	output.WriteLine("// generated by imageToHeader.go")
	output.WriteLine("// data format is " + os.Args[3] + " in range [0..255]")
	output.WriteLine("// the pxiel order is top to bottom, left to right")
	var gen codeGenerator
	if strings.HasSuffix(os.Args[2], ".h") {
		gen = &cGenerator{output}
	} else if strings.HasSuffix(os.Args[2], ".pas") {
		gen = &delphiGenerator{output}
	} else {
		panic("unknown file extension " + filepath.Ext(imageFileName))
	}
	gen.prefix(imageName)
	gen.imageSize(imageName, img.Bounds().Dx(), img.Bounds().Dy())

	// gather image data
	var data [][]uint8
	colorModel := color.NRGBAModel
	for y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {
		data = append(data, nil)
		for x := img.Bounds().Min.X; x < img.Bounds().Max.X; x++ {
			nrgba := colorModel.Convert(img.At(x, y)).(color.NRGBA)
			data[len(data)-1] = append(data[len(data)-1], formatData(nrgba)...)
		}
	}
	gen.data(imageName, data)

	gen.suffix()

	if err := ioutil.WriteFile(os.Args[2], buffer.Bytes(), 0666); err != nil {
		panic(err)
	}
}

type panickyWriter struct {
	buffer *bytes.Buffer
}

func (w panickyWriter) WriteString(s string) {
	_, err := w.buffer.WriteString(s)
	if err != nil {
		panic(err)
	}
}

func (w panickyWriter) WriteLine(line string) {
	w.WriteString(line + "\n")
}

func (w panickyWriter) unwrite(count int) {
	w.buffer.Truncate(w.buffer.Len() - count)
}

func formatData(c color.NRGBA) []uint8 {
	format := os.Args[3]
	channels := make([]uint8, 0, len(format))
	for _, channel := range format {
		switch channel {
		case 'R':
			channels = append(channels, c.R)
		case 'G':
			channels = append(channels, c.G)
		case 'B':
			channels = append(channels, c.B)
		case 'A':
			channels = append(channels, c.A)
		default:
			panic("illegal format character " + string(channel) +
				" (must be one of RGBA)")
		}
	}
	return channels
}

func formatColor(c color.NRGBA) string {
	format := os.Args[3]
	channels := make([]interface{}, 0, len(format))
	for _, channel := range format {
		switch channel {
		case 'R':
			channels = append(channels, c.R)
		case 'G':
			channels = append(channels, c.G)
		case 'B':
			channels = append(channels, c.B)
		case 'A':
			channels = append(channels, c.A)
		default:
			panic("illegal format character " + string(channel) +
				" (must be one of RGBA)")
		}
	}
	return fmt.Sprintf(strings.Repeat(" %v,", len(channels)), channels...)
}

type codeGenerator interface {
	prefix(name string)
	imageSize(name string, w, h int)
	data(name string, data [][]uint8)
	suffix()
}

type cGenerator struct{ w panickyWriter }

func (gen *cGenerator) prefix(name string) {}
func (gen *cGenerator) suffix()            {}

func (gen *cGenerator) imageSize(name string, w, h int) {
	gen.w.WriteLine(fmt.Sprintf("const unsigned int %vImageWidth = %v;",
		name, w))
	gen.w.WriteLine(fmt.Sprintf("const unsigned int %vImageHeight = %v;",
		name, h))
}

func (gen *cGenerator) data(name string, data [][]uint8) {
	gen.w.WriteString(fmt.Sprintf("unsigned char %vImageData[] = {", name))
	for _, line := range data {
		gen.w.WriteString("\n   ")
		for i := range line {
			gen.w.WriteString(" " + strconv.Itoa(int(line[i])) + ",")
		}
	}
	gen.w.unwrite(1)
	gen.w.WriteLine("")
	gen.w.WriteLine("};")
}

type delphiGenerator struct{ w panickyWriter }

func (gen *delphiGenerator) prefix(name string) {
	gen.w.WriteLine("unit " +
		strings.TrimSuffix(os.Args[2], filepath.Ext(os.Args[2])) +
		";\n")
	gen.w.WriteLine("interface\n")
	gen.w.WriteLine("const")
}

func (gen *delphiGenerator) suffix() {
	gen.w.WriteLine("implementation\n")
	gen.w.WriteLine("end.")
}

func (gen *delphiGenerator) imageSize(name string, w, h int) {
	gen.w.WriteLine(fmt.Sprintf("  %vImageWidth = %v;", name, w))
	gen.w.WriteLine(fmt.Sprintf("  %vImageHeight = %v;", name, h))
}

func (gen *delphiGenerator) data(name string, data [][]uint8) {
	gen.w.WriteLine(fmt.Sprintf("  %vImageData : array [0..%v] of Byte = (",
		name, len(data)*len(data[0])-1))
	var all []uint8
	for _, line := range data {
		all = append(all, line...)
	}
	const lineLength = 100
	for len(all) > 0 {
		var line []uint8
		if len(all) <= lineLength {
			line = all
			all = nil
		} else {
			line = all[:lineLength]
			all = all[lineLength:]
		}
		gen.w.WriteString("    ")
		for i := range line {
			gen.w.WriteString(strconv.Itoa(int(line[i])) + ", ")
		}
		gen.w.unwrite(1)
		gen.w.WriteLine("")
	}
	gen.w.unwrite(2)
	gen.w.WriteLine("")
	gen.w.WriteLine("  );\n")
}
